@page "/"
@inject AdminMetricsService Metrics
@inject IJSRuntime JS
@inject IConfiguration Configuration
@using System.Collections.Generic
@using System.IO
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@implements IAsyncDisposable

<section class="admin-header">
    <div>
        <p class="eyebrow">Orleans Telemetry - Admin Console</p>
        <h1>Cluster Overview</h1>
    </div>
    <button class="refresh-button" @onclick="RefreshAsync">Refresh</button>
</section>

@if (_loading)
{
    <p class="status">Loading dashboard data...</p>
}
else if (_error is not null)
{
    <p class="status error">@_error</p>
}
else
{
    <main class="layout-content">
        <section class="overview">
            <article>
                <h2>Ingest</h2>
                <p>Batch size: @_ingest?.BatchSize</p>
                <p>Channel capacity: @_ingest?.ChannelCapacity</p>
                <div class="tag-row">
                    <strong>Connectors</strong>
                    @if (_ingest?.EnabledConnectors.Length > 0)
                    {
                        @foreach (var connector in _ingest.EnabledConnectors)
                        {
                            <span class="tag">@connector</span>
                        }
                    }
                    else
                    {
                        <span class="tag muted">None</span>
                    }
                </div>
                <div class="tag-row">
                    <strong>Event sinks</strong>
                    @if (_ingest?.EnabledSinks.Length > 0)
                    {
                        @foreach (var sink in _ingest.EnabledSinks)
                        {
                            <span class="tag">@sink</span>
                        }
                    }
                    else
                    {
                        <span class="tag muted">None</span>
                    }
                </div>
            </article>
            <article>
                <h2>Storage</h2>
                @if (_storage is not null)
                {
                    <p>Stage: @_storage.Stage.FileCount files</p>
                    <p>Parquet: @_storage.Parquet.FileCount files</p>
                    <p>Index: @_storage.Index.FileCount files</p>
                }
                else
                {
                    <p>Storage stats unavailable.</p>
                }
            </article>
            <article>
                <h2>Clients</h2>
                <p>Silos: @_silos.Length</p>
                <p>Total clients: @(_silos.Sum(s => s.ClientCount))</p>
            </article>
        </section>

        <section>
            <h2>Control Routing</h2>
            @if (_controlRoutingLoading)
            {
                <p class="status muted">Loading control routing config...</p>
            }
            else
            {
                <div class="table-scroll">
                    <table>
                        <thead>
                            <tr>
                                <th>Connector</th>
                                <th>Mapped Gateway IDs</th>
                                <th>Enabled</th>
                            </tr>
                        </thead>
                        <tbody>
                            @if (_controlRoutingConnectors.Count == 0)
                            {
                                <tr>
                                    <td colspan="3" class="muted">No connector-gateway mappings defined.</td>
                                </tr>
                            }
                            else
                            {
                                @foreach (var mapping in _controlRoutingConnectors)
                                {
                                    <tr>
                                        <td>@mapping.Connector</td>
                                        <td>@(mapping.GatewayIds.Count == 0 ? "-" : string.Join(", ", mapping.GatewayIds))</td>
                                        <td>@(mapping.IsEnabled ? "Yes" : "No")</td>
                                    </tr>
                                }
                            }
                        </tbody>
                    </table>
                </div>

                <div class="control-routing-editor">
                    <label for="control-routing-json">Routing Config JSON</label>
                    <textarea id="control-routing-json" class="graph-input" rows="14" @bind="_controlRoutingJson"></textarea>
                    <div class="graph-import-actions">
                        <button class="refresh-button button-ghost" @onclick="ReloadControlRoutingAsync" disabled="_controlRoutingSaving">Reload</button>
                        <button class="refresh-button" @onclick="SaveControlRoutingAsync" disabled="_controlRoutingSaving">
                            @(_controlRoutingSaving ? "Saving..." : "Save Routing Config")
                        </button>
                    </div>
                </div>

                @if (!string.IsNullOrWhiteSpace(_controlRoutingMessage))
                {
                    <p class="status muted">@_controlRoutingMessage</p>
                }
                @if (!string.IsNullOrWhiteSpace(_controlRoutingError))
                {
                    <p class="status error">@_controlRoutingError</p>
                }
            }
        </section>

        <section>
            <h2>Activation Explorer (@_grains.Length types)</h2>
            @if (_grains.Length == 0)
            {
                <p class="status muted">No grain activations yet.</p>
            }
            else
            {
                <div class="table-scroll">
                    <table>
                        <thead>
                            <tr>
                                <th>Grain Type</th>
                                <th>Activations</th>
                                <th>Silos</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var grain in _grains)
                            {
                                <tr>
                                    <td>@grain.GrainType</td>
                                    <td class="numeric">@grain.ActivationCount</td>
                                    <td>@string.Join(", ", grain.Silos)</td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
            }
        </section>

        <section>
            <div class="graph-card-header">
                <h2>Grain Placement (Detailed Stats)</h2>
                <button class="refresh-button button-ghost" @onclick="LoadGrainHierarchyAsync">Refresh Placement</button>
            </div>
            @if (_loadingGrainHierarchy)
            {
                <p class="status">Loading grain placement...</p>
            }
            else if (!string.IsNullOrWhiteSpace(_grainHierarchyError))
            {
                <p class="status error">@_grainHierarchyError</p>
            }
            else if (_grainHierarchy.Count == 0)
            {
                <p class="status muted">No detailed grain placement data available.</p>
            }
            else
            {
                <div class="grain-tree">
                    <MudTreeView T="GrainHierarchyNode" Hover="true" Class="grain-tree-view">
                        @RenderGrainHierarchy(_grainHierarchy)
                    </MudTreeView>
                </div>
            }
        </section>

        <section>
            <h2>Client Connections</h2>
            @if (_silos.Length == 0)
            {
                <p class="status muted">No active silos detected.</p>
            }
            else
            {
                <div class="table-scroll">
                    <table>
                        <thead>
                            <tr>
                                <th>Silo</th>
                                <th>Status</th>
                                <th>Clients</th>
                                <th>Activations</th>
                                <th>CPU (%)</th>
                                <th>Memory (used / max)</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var silo in _silos)
                            {
                                <tr>
                                    <td>@silo.SiloAddress</td>
                                    <td>@silo.Status</td>
                                    <td class="numeric">@silo.ClientCount</td>
                                    <td class="numeric">@silo.ActivationCount</td>
                                    <td>@FormatPercent(silo.CpuUsagePercentage)</td>
                                    <td>@FormatMemoryUsage(silo.MemoryUsageBytes, silo.MaximumAvailableMemoryBytes)</td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
            }
        </section>

        <section>
            <h2>Storage Buckets</h2>
            <div class="tier-grid">
                @if (_storage is not null)
                {
                    @foreach (var tier in new[] { _storage.Stage, _storage.Parquet, _storage.Index })
                    {
                        <article>
                            <h3>@tier.Tier</h3>
                            <p>@FormatBytes(tier.TotalBytes) / @tier.FileCount files</p>
                            <p class="muted">Root: @tier.RootPath</p>
                            <ul>
                                @if (tier.Tenants.Count == 0)
                                {
                                    <li class="muted">No active tenants.</li>
                                }
                                else
                                {
                                    @foreach (var tenant in tier.Tenants)
                                    {
                                        <li>@tenant.TenantId / @tenant.FileCount files / @FormatBytes(tenant.TotalBytes)</li>
                                    }
                                }
                            </ul>
                        </article>
                    }
                }
                else
                {
                    <p class="status muted">Storage stats failed to load.</p>
                }
            </div>
        </section>

        <section class="graph-card">
            <div class="graph-card-header">
                <h2>Spatial Hierarchy</h2>
                <button class="refresh-button button-ghost" @onclick="LoadSpatialHierarchyAsync" disabled="@string.IsNullOrWhiteSpace(_selectedGraphTenant)">Load Hierarchy</button>
            </div>
            <div class="graph-tenant-selector">
                @if (_graphTenants.Length > 0)
                {
                    <label>
                        Tenant
                        <select class="graph-input" value="@_selectedGraphTenant" @onchange="OnGraphTenantSelectionChanged">
                            @foreach (var tenant in _graphTenants)
                            {
                                <option value="@tenant">@tenant</option>
                            }
                        </select>
                    </label>
                }
                else
                {
                    <p class="status muted">Import RDF to register tenant IDs.</p>
                }
            </div>
            @if (string.IsNullOrWhiteSpace(_selectedGraphTenant))
            {
                <p class="status muted">Select a tenant.</p>
            }
            else if (_loadingHierarchy)
            {
                <p class="status">Loading hierarchy...</p>
            }
            else if (!string.IsNullOrWhiteSpace(_hierarchyError))
            {
                <p class="status error">@_hierarchyError</p>
            }
            else if (_graphTreeNodes.Count == 0)
            {
                <p class="status muted">No hierarchy data available.</p>
            }
            else
            {
                <div class="graph-tree-layout">
                    <MudPaper Class="pa-3 graph-tree-panel">
                        <MudText Typo="Typo.subtitle1">Hierarchy Tree</MudText>
                        <MudTreeView T="GraphTreeNode" Hover="true" Class="graph-tree-view">
                            @RenderGraphTree(_graphTreeNodes)
                        </MudTreeView>
                    </MudPaper>
                    <MudPaper Class="pa-3 graph-tree-details">
                        <MudText Typo="Typo.subtitle1">Node Details</MudText>
                        @if (_selectedGraphNodeDetails is not null)
                        {
                            <MudText Typo="Typo.h6">@GetNodeLabel(_selectedGraphNodeDetails.Snapshot)</MudText>
                            <table class="details-table">
                                <tbody>
                                    <tr>
                                        <th>ID</th>
                                        <td>@_selectedGraphNodeDetails.Snapshot.Node.NodeId</td>
                                    </tr>
                                    <tr>
                                        <th>Type</th>
                                        <td>@_selectedGraphNodeDetails.Snapshot.Node.NodeType</td>
                                    </tr>
                                </tbody>
                            </table>
                            <MudText Typo="Typo.subtitle2" Class="mt-2">Attributes</MudText>
                            @if (_selectedGraphNodeDetails.Snapshot.Node.Attributes.Count == 0)
                            {
                                <MudText Typo="Typo.body2" Class="muted">No attributes.</MudText>
                            }
                            else
                            {
                                <table class="details-table">
                                    <tbody>
                                        @foreach (var attr in _selectedGraphNodeDetails.Snapshot.Node.Attributes.OrderBy(kvp => kvp.Key, StringComparer.OrdinalIgnoreCase))
                                        {
                                            <tr>
                                                <th>@attr.Key</th>
                                                <td>@attr.Value</td>
                                            </tr>
                                        }
                                    </tbody>
                                </table>
                            }

                            <MudText Typo="Typo.subtitle2" Class="mt-2">Outgoing Edges</MudText>
                            @if (_selectedGraphNodeDetails.Snapshot.OutgoingEdges.Count == 0)
                            {
                                <MudText Typo="Typo.body2" Class="muted">No outgoing edges.</MudText>
                            }
                            else
                            {
                                <table class="details-table">
                                    <thead>
                                        <tr>
                                            <th>Predicate</th>
                                            <th>Target</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        @foreach (var edge in _selectedGraphNodeDetails.Snapshot.OutgoingEdges)
                                        {
                                            <tr>
                                                <td>@edge.Predicate</td>
                                                <td>@edge.TargetNodeId</td>
                                            </tr>
                                        }
                                    </tbody>
                                </table>
                            }

                            <MudText Typo="Typo.subtitle2" Class="mt-2">Incoming Edges</MudText>
                            @if (_selectedGraphNodeDetails.Snapshot.IncomingEdges.Count == 0)
                            {
                                <MudText Typo="Typo.body2" Class="muted">No incoming edges.</MudText>
                            }
                            else
                            {
                                <table class="details-table">
                                    <thead>
                                        <tr>
                                            <th>Predicate</th>
                                            <th>Source</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        @foreach (var edge in _selectedGraphNodeDetails.Snapshot.IncomingEdges)
                                        {
                                            <tr>
                                                <td>@edge.Predicate</td>
                                                <td>@edge.TargetNodeId</td>
                                            </tr>
                                        }
                                    </tbody>
                                </table>
                            }

                            @if (_selectedGraphNodeDetails.Snapshot.Node.NodeType == GraphNodeType.Point)
                            {
                                <MudText Typo="Typo.subtitle2" Class="mt-2">Point Snapshot</MudText>
                                @if (_selectedGraphNodeDetails.PointSnapshot is null)
                                {
                                    <MudText Typo="Typo.body2" Class="muted">Point snapshot unavailable.</MudText>
                                }
                                else
                                {
                                    <table class="details-table">
                                        <tbody>
                                            <tr>
                                                <th>Key</th>
                                                <td>@_selectedGraphNodeDetails.PointGrainKey</td>
                                            </tr>
                                            <tr>
                                                <th>Sequence</th>
                                                <td>@_selectedGraphNodeDetails.PointSnapshot.LastSequence</td>
                                            </tr>
                                            <tr>
                                                <th>Value</th>
                                                <td>@_selectedGraphNodeDetails.PointSnapshot.LatestValue</td>
                                            </tr>
                                            <tr>
                                                <th>Updated</th>
                                                <td>@_selectedGraphNodeDetails.PointSnapshot.UpdatedAt:u</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                }

                                <MudText Typo="Typo.subtitle2" Class="mt-4">Telemetry Trend</MudText>
                                <div class="point-trend-controls mt-2">
                                    <label>
                                        Query Range
                                        <select class="graph-input"
                                                value="@_selectedTrendRangeKey"
                                                @onchange="OnTrendRangeChanged"
                                                disabled="@_pointTrendLoading">
                                            @foreach (var option in TrendRangeOptions)
                                            {
                                                <option value="@option.Key">@option.Label</option>
                                            }
                                        </select>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                                        <input type="checkbox" @onchange="OnRealTimeCheckboxChanged" checked="@_enableRealTimeUpdate" disabled="@_pointTrendLoading" />
                                        Real-time update
                                        @if (_enableRealTimeUpdate && _isSubscribedToUpdates)
                                        {
                                            <span class="badge badge-success" style="display: flex; align-items: center; gap: 0.25rem;">
                                                <span class="pulse-dot"></span> Live
                                            </span>
                                        }
                                    </label>
                                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Disabled="@_pointTrendLoading" OnClick="LoadPointTrendAsync">
                                        @if (_pointTrendLoading)
                                        {
                                            <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                                        }
                                        else
                                        {
                                            <MudText>Load Telemetry</MudText>
                                        }
                                    </MudButton>
                                    @if (_pointTrendRequested && !_pointTrendLoading && string.IsNullOrWhiteSpace(_pointTrendError))
                                    {
                                        <MudText Typo="Typo.caption" Color="Color.Secondary">@_pointTrendStatusText</MudText>
                                    }
                                </div>

                                @if (_pointTrendLoading)
                                {
                                    <MudProgressLinear Indeterminate="true" Class="mt-2" />
                                }
                                else if (!string.IsNullOrWhiteSpace(_pointTrendError))
                                {
                                    <MudText Typo="Typo.body2" Color="Color.Error" Class="mt-2">@_pointTrendError</MudText>
                                }
                                else if (_pointTrendRequested && _pointTrendSamples.Any(sample => sample.Value.HasValue))
                                {
                                    <TelemetryTrendChart Samples="_pointTrendSamples"
                                                         Title="Latest telemetry trend" />
                                }
                                else if (_pointTrendRequested)
                                {
                                    <MudText Typo="Typo.body2" Class="muted mt-2">No telemetry samples available.</MudText>
                                }
                            }
                        }
                        else
                        {
                            <MudText Typo="Typo.body2" Class="muted">Select a node to view details.</MudText>
                        }
                    </MudPaper>
                </div>
            }
        </section>

        <section>
            <h2>Graph RDF Import</h2>
            <div class="graph-import-grid">
                <div class="graph-import">
                    <label>
                        RDF file
                        <InputFile OnChange="HandleGraphFileSelected" class="graph-input" accept=".ttl,.rdf,.nt,.nq,.jsonld" />
                    </label>
                    <label>
                        Tenant ID
                        <input class="graph-input" @bind="_graphTenant" />
                    </label>
                    <label>
                        Tenant Name
                        <input class="graph-input" @bind="_graphTenantName" placeholder="Optional (defaults to Tenant ID)" />
                    </label>
                    <div class="graph-import-actions">
                        <button class="refresh-button" @onclick="TriggerGraphSeedAsync" disabled="@_isImporting">
                            @(_isImporting ? "Importing..." : "Run import")
                        </button>
                        @if (!string.IsNullOrWhiteSpace(_uploadedGraphPath))
                        {
                            <button class="refresh-button button-ghost" @onclick="ClearUploadedGraphAsync" disabled="@_isImporting">
                                Clear upload
                            </button>
                        }
                    </div>
                </div>
                <div class="graph-status-card">
                    <div class="graph-status-header">
                        <span>Last execution</span>
                        <span class="@GetGraphStatusBadgeClass(_graphStatus)">@GetGraphStatusLabel(_graphStatus)</span>
                    </div>
                    @if (_graphStatus is not null)
                    {
                        <p class="graph-status-line">Path: @_graphStatus.Path</p>
                        <p class="graph-status-line">Tenant: @_graphStatus.TenantId</p>
                        @if (!string.IsNullOrWhiteSpace(_graphStatus.TenantName))
                        {
                            <p class="graph-status-line">Tenant Name: @_graphStatus.TenantName</p>
                        }
                        <p class="graph-status-line">@_graphStatus.StartedAt:u / @_graphStatus.CompletedAt:u</p>
                        <p class="graph-status-line">Nodes: @_graphStatus.NodeCount / Edges: @_graphStatus.EdgeCount</p>
                        @if (!string.IsNullOrWhiteSpace(_graphStatus.Message))
                        {
                            <p class="graph-status-line status muted">Message: @_graphStatus.Message</p>
                        }
                    }
                    else
                    {
                        <p class="graph-status-line muted">No graph seed history.</p>
                    }
                </div>
            </div>
            @if (!string.IsNullOrWhiteSpace(_graphUploadMessage))
            {
                <p class="status muted">@_graphUploadMessage</p>
            }
            @if (!string.IsNullOrWhiteSpace(_graphUploadError))
            {
                <p class="status error">@_graphUploadError</p>
            }
            @if (!string.IsNullOrWhiteSpace(_graphFeedback))
            {
                <p class="status">@_graphFeedback</p>
            }
        </section>

    </main>
}

@code {
    private GrainActivationSummary[] _grains = Array.Empty<GrainActivationSummary>();
    private SiloSummary[] _silos = Array.Empty<SiloSummary>();
    private StorageOverview? _storage;
    private IngestSummary? _ingest;
    private IReadOnlyList<GrainHierarchyNode> _grainHierarchy = Array.Empty<GrainHierarchyNode>();
    private bool _loadingGrainHierarchy;
    private string? _grainHierarchyError;
    private bool _loading = true;
    private string? _error;
    private string _graphTenant = "default";
    private string _graphTenantName = "default";
    private GraphSeedStatus? _graphStatus;
    private bool _isImporting;
    private string? _graphFeedback;
    private string[] _graphTenants = Array.Empty<string>();
    private bool _controlRoutingLoading;
    private bool _controlRoutingSaving;
    private string _controlRoutingJson = "{}";
    private string? _controlRoutingMessage;
    private string? _controlRoutingError;
    private List<ControlRoutingConnectorView> _controlRoutingConnectors = new();
    private string? _selectedGraphTenant;
    private List<GraphTreeNode> _graphTreeNodes = new();
    private GraphNodeDetailView? _selectedGraphNodeDetails;
    private bool _loadingHierarchy;
    private string? _hierarchyError;
    private string? _uploadedGraphPath;
    private string? _uploadedGraphFileName;
    private string? _graphUploadMessage;
    private string? _graphUploadError;
    private HashSet<string> _expandedGraphNodes = new(StringComparer.OrdinalIgnoreCase);
    private IReadOnlyList<PointTrendSample> _pointTrendSamples = Array.Empty<PointTrendSample>();
    private bool _pointTrendRequested;
    private bool _pointTrendLoading;
    private string? _pointTrendError;
    private string? _pointTrendStatusText;
    private string _selectedTrendRangeKey = "15m";
    private bool _enableRealTimeUpdate;
    private bool _isSubscribedToUpdates;
    private DotNetObjectReference<Admin>? _dotNetRef;
    private string? _currentSubscriptionTenant;
    private string? _currentSubscriptionDevice;
    private string? _currentSubscriptionPoint;
    private const long DefaultGraphUploadLimitBytes = 10 * 1024 * 1024;
    private static readonly IReadOnlyList<TrendRangeOption> TrendRangeOptions = new[]
    {
        new TrendRangeOption("5m", "Last 5 minutes", TimeSpan.FromMinutes(5), 120),
        new TrendRangeOption("15m", "Last 15 minutes", TimeSpan.FromMinutes(15), 180),
        new TrendRangeOption("1h", "Last 1 hour", TimeSpan.FromHours(1), 240),
        new TrendRangeOption("6h", "Last 6 hours", TimeSpan.FromHours(6), 360)
    };

    protected override async Task OnInitializedAsync()
    {
        _dotNetRef = DotNetObjectReference.Create(this);
        await RefreshAsync();
    }

    private async Task RefreshAsync()
    {
        _loading = true;
        _error = null;
        try
        {
            _grains = await Metrics.GetGrainActivationsAsync();
            _silos = await Metrics.GetSiloSummariesAsync();
            _storage = await Metrics.GetStorageOverviewAsync(CancellationToken.None);
            _ingest = Metrics.GetIngestSummary();
            await LoadGrainHierarchyAsync();
            _graphStatus = await Metrics.GetLastGraphSeedStatusAsync();
            await LoadGraphTenantOptionsAsync();
            await LoadSpatialHierarchyAsync();
            await LoadControlRoutingAsync();
        }
        catch (Exception ex)
        {
            _error = $"Failed to load dashboard data: {ex.Message}";
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    private async Task LoadSpatialHierarchyAsync()
    {
        // Stop real-time updates when loading new hierarchy
        if (_enableRealTimeUpdate)
        {
            await StopRealTimeUpdatesAsync();
            _enableRealTimeUpdate = false;
        }

        if (string.IsNullOrWhiteSpace(_selectedGraphTenant))
        {
            _graphTreeNodes.Clear();
            _selectedGraphNodeDetails = null;
            _expandedGraphNodes.Clear();
            ResetPointTrend();
            return;
        }

        _loadingHierarchy = true;
        _hierarchyError = null;
        try
        {
            _graphTreeNodes = (await Metrics.GetGraphTreeAsync(_selectedGraphTenant)).ToList();
            _selectedGraphNodeDetails = null;
            _expandedGraphNodes = BuildExpandedGraphNodes(_graphTreeNodes);
            ResetPointTrend();
        }
        catch (Exception ex)
        {
            _hierarchyError = $"Failed to load hierarchy: {ex.Message}";
        }
        finally
        {
            _loadingHierarchy = false;
            StateHasChanged();
        }
    }

    private async Task LoadGraphTenantOptionsAsync()
    {
        var tenants = await Metrics.GetGraphTenantsAsync();
        _graphTenants = tenants ?? Array.Empty<string>();

        if (_graphTenants.Length == 0)
        {
            _selectedGraphTenant = null;
            return;
        }

        if (string.IsNullOrWhiteSpace(_selectedGraphTenant) ||
            !Array.Exists(_graphTenants, tenant => string.Equals(tenant, _selectedGraphTenant, StringComparison.OrdinalIgnoreCase)))
        {
            _selectedGraphTenant = _graphTenants[0];
        }

        if (string.Equals(_graphTenant, "default", StringComparison.OrdinalIgnoreCase) &&
            !string.IsNullOrWhiteSpace(_selectedGraphTenant))
        {
            _graphTenant = _selectedGraphTenant;
            if (string.IsNullOrWhiteSpace(_graphTenantName) || string.Equals(_graphTenantName, "default", StringComparison.OrdinalIgnoreCase))
            {
                _graphTenantName = _selectedGraphTenant;
            }
        }
    }

    private async Task LoadControlRoutingAsync()
    {
        _controlRoutingLoading = true;
        _controlRoutingError = null;
        _controlRoutingMessage = null;

        try
        {
            var routing = await Metrics.GetControlRoutingViewAsync();
            _controlRoutingJson = routing.RawJson;
            _controlRoutingConnectors = routing.ConnectorMappings.ToList();
            _controlRoutingMessage = $"Config path: {routing.ConfigPath}";
        }
        catch (Exception ex)
        {
            _controlRoutingError = $"Failed to load control routing: {ex.Message}";
        }
        finally
        {
            _controlRoutingLoading = false;
        }
    }

    private async Task ReloadControlRoutingAsync()
    {
        await LoadControlRoutingAsync();
        StateHasChanged();
    }

    private async Task SaveControlRoutingAsync()
    {
        _controlRoutingSaving = true;
        _controlRoutingError = null;
        _controlRoutingMessage = null;

        try
        {
            var routing = await Metrics.SaveControlRoutingConfigAsync(_controlRoutingJson);
            _controlRoutingJson = routing.RawJson;
            _controlRoutingConnectors = routing.ConnectorMappings.ToList();
            _controlRoutingMessage = $"Saved: {routing.ConfigPath}";
        }
        catch (Exception ex)
        {
            _controlRoutingError = $"Failed to save control routing: {ex.Message}";
        }
        finally
        {
            _controlRoutingSaving = false;
            StateHasChanged();
        }
    }

    private async Task OnGraphTenantSelectionChanged(ChangeEventArgs args)
    {
        if (args?.Value is not string tenant || string.IsNullOrWhiteSpace(tenant))
        {
            return;
        }

        // Stop real-time updates when tenant changes
        if (_enableRealTimeUpdate)
        {
            await StopRealTimeUpdatesAsync();
            _enableRealTimeUpdate = false;
        }

        _selectedGraphTenant = tenant;
        _selectedGraphNodeDetails = null;
        ResetPointTrend();
        await LoadSpatialHierarchyAsync();
        StateHasChanged();
    }

    private async Task LoadGrainHierarchyAsync()
    {
        _loadingGrainHierarchy = true;
        _grainHierarchyError = null;
        try
        {
            _grainHierarchy = await Metrics.GetGrainHierarchyAsync();
        }
        catch (Exception ex)
        {
            _grainHierarchyError = $"Failed to load grain placement: {ex.Message}";
        }
        finally
        {
            _loadingGrainHierarchy = false;
            StateHasChanged();
        }
    }

    private RenderFragment RenderGrainHierarchy(IReadOnlyList<GrainHierarchyNode> nodes) => builder =>
    {
        var sequence = 0;
        foreach (var node in nodes)
        {
            builder.OpenComponent<MudTreeViewItem<GrainHierarchyNode>>(sequence++);
            builder.AddAttribute(sequence++, "Value", node);
            builder.AddAttribute(sequence++, "Text", node.Label);
            builder.AddAttribute(sequence++, "Icon", GetGrainHierarchyIcon(node.Kind));
            builder.AddAttribute(sequence++, "CanExpand", node.Children.Count > 0);
            builder.AddAttribute(sequence++, "Expanded", node.Kind is GrainHierarchyNodeKind.Silo or GrainHierarchyNodeKind.GrainType);
            if (node.Children.Count > 0)
            {
                builder.AddAttribute(sequence++, "ChildContent", RenderGrainHierarchy(node.Children));
            }
            builder.CloseComponent();
        }
    };

    private RenderFragment RenderGraphTree(IReadOnlyList<GraphTreeNode> nodes) => builder =>
    {
        var sequence = 0;
        foreach (var node in nodes)
        {
            builder.OpenComponent<MudTreeViewItem<GraphTreeNode>>(sequence++);
            builder.AddAttribute(sequence++, "Value", node);
            builder.AddAttribute(sequence++, "Text", node.DisplayName);
            builder.AddAttribute(sequence++, "Icon", GetTreeIcon(node.NodeType));
            builder.AddAttribute(sequence++, "CanExpand", node.Children.Count > 0);
            builder.AddAttribute(sequence++, "Expanded", _expandedGraphNodes.Contains(node.NodeId));
            builder.AddAttribute(sequence++, "ExpandedChanged", EventCallback.Factory.Create<bool>(this, expanded =>
            {
                if (expanded)
                {
                    _expandedGraphNodes.Add(node.NodeId);
                }
                else
                {
                    _expandedGraphNodes.Remove(node.NodeId);
                }
            }));
            builder.AddAttribute(sequence++, "OnClick", EventCallback.Factory.Create<MouseEventArgs>(this, _ => SelectGraphNodeAsync(node.NodeId)));
            if (node.Children.Count > 0)
            {
                builder.AddAttribute(sequence++, "ChildContent", RenderGraphTree(node.Children));
            }
            builder.CloseComponent();
        }
    };

    private async Task SelectGraphNodeAsync(string nodeId)
    {
        var shouldRestoreRealtime = _enableRealTimeUpdate;

        if (shouldRestoreRealtime)
        {
            await StopRealTimeUpdatesAsync();
        }

        if (string.IsNullOrWhiteSpace(nodeId) || string.IsNullOrWhiteSpace(_selectedGraphTenant))
        {
            _selectedGraphNodeDetails = null;
            ResetPointTrend();
            return;
        }

        _selectedGraphNodeDetails = await Metrics.GetGraphNodeDetailsAsync(_selectedGraphTenant, nodeId);
        ResetPointTrend();

        if (shouldRestoreRealtime)
        {
            if (_selectedGraphNodeDetails?.Snapshot.Node.NodeType == GraphNodeType.Point)
            {
                _enableRealTimeUpdate = true;
                await StartRealTimeUpdatesAsync();
            }
            else
            {
                _enableRealTimeUpdate = false;
                _pointTrendError = "Select a point node before enabling real-time updates.";
            }
        }

        StateHasChanged();
    }

    private async Task LoadPointTrendAsync()
    {
        if (_selectedGraphNodeDetails?.PointGrainKey is null || string.IsNullOrWhiteSpace(_selectedGraphTenant))
        {
            return;
        }

        _pointTrendRequested = true;
        _pointTrendLoading = true;
        _pointTrendError = null;
        _pointTrendStatusText = null;
        _pointTrendSamples = Array.Empty<PointTrendSample>();

        try
        {
            if (!TryResolvePointQueryContext(
                _selectedGraphNodeDetails,
                _selectedGraphTenant!,
                out var tenantId,
                out var deviceId,
                out var pointId))
            {
                _pointTrendError = "Point trend context is missing required IDs.";
                return;
            }

            var range = GetSelectedTrendRange();
            _pointTrendSamples = await Metrics.QueryPointTrendHybridAsync(
                tenantId,
                deviceId,
                pointId,
                range.Duration,
                range.MaxSamples);

            if (_pointTrendSamples.Count == 0)
            {
                _pointTrendStatusText = $"No samples for {range.Label}.";
                return;
            }

            _pointTrendStatusText = $"Loaded {_pointTrendSamples.Count} samples ({range.Label}).";
            if (_pointTrendSamples.All(sample => !sample.Value.HasValue))
            {
                _pointTrendError = "Telemetry values are non-numeric and cannot be charted.";
            }
        }
        catch (Exception ex)
        {
            _pointTrendError = $"Failed to load telemetry trend: {ex.Message}";
        }
        finally
        {
            _pointTrendLoading = false;
            StateHasChanged();
        }
    }

    private static string GetGrainHierarchyIcon(GrainHierarchyNodeKind kind)
        => kind switch
        {
            GrainHierarchyNodeKind.Silo => Icons.Material.Filled.Storage,
            GrainHierarchyNodeKind.GrainType => Icons.Material.Filled.Category,
            GrainHierarchyNodeKind.GrainId => Icons.Material.Filled.Memory,
            GrainHierarchyNodeKind.Info => Icons.Material.Filled.MoreHoriz,
            _ => Icons.Material.Filled.DeviceHub
        };

    private static string GetTreeIcon(GraphNodeType type)
        => type switch
        {
            GraphNodeType.Site => Icons.Material.Filled.Public,
            GraphNodeType.Building => Icons.Material.Filled.HomeWork,
            GraphNodeType.Level => Icons.Material.Filled.Layers,
            GraphNodeType.Area => Icons.Material.Filled.Map,
            GraphNodeType.Equipment => Icons.Material.Filled.Memory,
            GraphNodeType.Device => Icons.Material.Filled.Memory,
            GraphNodeType.Point => Icons.Material.Filled.ControlPoint,
            _ => Icons.Material.Filled.DeviceHub
        };

    private static bool IsLevelNode(GraphTreeNode node) => node.NodeType == GraphNodeType.Level;

    private static HashSet<string> BuildExpandedGraphNodes(IEnumerable<GraphTreeNode> nodes)
    {
        var expanded = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        foreach (var node in nodes)
        {
            ExpandToLevel(node, expanded);
        }

        return expanded;
    }

    private static void ExpandToLevel(GraphTreeNode node, HashSet<string> expanded)
    {
        if (IsLevelNode(node))
        {
            return;
        }

        if (node.Children.Count == 0)
        {
            return;
        }

        expanded.Add(node.NodeId);
        foreach (var child in node.Children)
        {
            ExpandToLevel(child, expanded);
        }
    }

    private void ResetPointTrend()
    {
        _pointTrendSamples = Array.Empty<PointTrendSample>();
        _pointTrendRequested = false;
        _pointTrendLoading = false;
        _pointTrendError = null;
        _pointTrendStatusText = null;
    }

    private void OnTrendRangeChanged(ChangeEventArgs args)
    {
        if (args.Value is string value && TrendRangeOptions.Any(option => option.Key == value))
        {
            _selectedTrendRangeKey = value;
        }
    }

    private TrendRangeOption GetSelectedTrendRange()
        => TrendRangeOptions.FirstOrDefault(option => option.Key == _selectedTrendRangeKey)
           ?? TrendRangeOptions[1];

    private static bool TryResolvePointQueryContext(
        GraphNodeDetailView details,
        string tenantId,
        out string resolvedTenant,
        out string deviceId,
        out string pointId)
    {
        resolvedTenant = tenantId;
        deviceId = string.Empty;
        pointId = string.Empty;

        // Prefer DeviceId from GraphNodeDetailView (resolved by server)
        if (!string.IsNullOrWhiteSpace(details.DeviceId))
        {
            deviceId = details.DeviceId;
        }
        else
        {
            // Fallback to attributes
            var attributes = details.Snapshot.Node.Attributes;
            if (attributes.TryGetValue("DeviceId", out var device) && !string.IsNullOrWhiteSpace(device))
            {
                deviceId = device;
            }
        }

        // Resolve Point ID
        var attributes2 = details.Snapshot.Node.Attributes;
        if (attributes2.TryGetValue("PointId", out var point) && !string.IsNullOrWhiteSpace(point))
        {
            pointId = point;
        }
        else if (!string.IsNullOrWhiteSpace(details.PointGrainKey))
        {
            var separator = details.PointGrainKey.IndexOf(':');
            pointId = separator >= 0 && separator < details.PointGrainKey.Length - 1
                ? details.PointGrainKey[(separator + 1)..]
                : details.PointGrainKey;
        }

        if (string.IsNullOrWhiteSpace(deviceId) || string.IsNullOrWhiteSpace(pointId))
        {
            return false;
        }

        return true;
    }

    private sealed record TrendRangeOption(string Key, string Label, TimeSpan Duration, int MaxSamples);

    private static string GetNodeLabel(GraphNodeSnapshot snapshot)
    {
        var node = snapshot.Node;
        return !string.IsNullOrWhiteSpace(node.DisplayName) ? node.DisplayName : node.NodeId;
    }

    private static string FormatBytes(long? bytes) => FormatBytes((double?)bytes);

    private static string FormatBytes(double? bytes)
    {
        if (!bytes.HasValue)
        {
            return "-";
        }

        var value = bytes.Value;
        var units = new[] { "B", "KB", "MB", "GB", "TB" };
        var index = 0;
        while (value >= 1024 && index < units.Length - 1)
        {
            value /= 1024;
            index++;
        }

        return $"{value:F1} {units[index]}";
    }

    private static string FormatPercent(double? value)
        => value.HasValue ? $"{value.Value:F1}%" : "-";

    private static string FormatMemoryUsage(double? used, double? available)
    {
        if (!used.HasValue && !available.HasValue)
        {
            return "-";
        }

        var usedText = FormatBytes(used);
        if (!available.HasValue)
        {
            return usedText;
        }

        return $"{usedText} / {FormatBytes(available)}";
    }

    private static string GetGraphStatusLabel(GraphSeedStatus? status)
        => status is null ? "Not run" : status.Success ? "Success" : "Failure";

    private static string GetGraphStatusBadgeClass(GraphSeedStatus? status)
        => status is null ? "status-badge muted" : status.Success ? "status-badge success" : "status-badge failure";

    private async Task HandleGraphFileSelected(InputFileChangeEventArgs args)
    {
        _graphUploadError = null;
        _graphUploadMessage = null;

        var file = args.File;
        if (file is null)
        {
            _graphUploadError = "No file selected.";
            return;
        }

        var maxBytes = GetGraphUploadMaxBytes();
        if (file.Size > maxBytes)
        {
            _graphUploadError = $"File too large. Max {FormatBytes(maxBytes)}.";
            return;
        }

        var uploadDir = GetGraphUploadDirectory();
        Directory.CreateDirectory(uploadDir);

        if (!string.IsNullOrWhiteSpace(_uploadedGraphPath))
        {
            TryDeleteFile(_uploadedGraphPath);
        }

        var safeFileName = Path.GetFileName(file.Name);
        var uniqueName = $"{DateTime.UtcNow:yyyyMMddHHmmss}_{Guid.NewGuid():N}_{safeFileName}";
        var targetPath = Path.Combine(uploadDir, uniqueName);

        await using var input = file.OpenReadStream(maxBytes);
        await using var output = File.Create(targetPath);
        await input.CopyToAsync(output);

        _uploadedGraphPath = targetPath;
        _uploadedGraphFileName = safeFileName;
        _graphUploadMessage = $"Uploaded {_uploadedGraphFileName}. Using uploaded file for import.";
    }

    private Task ClearUploadedGraphAsync()
    {
        if (!string.IsNullOrWhiteSpace(_uploadedGraphPath))
        {
            TryDeleteFile(_uploadedGraphPath);
        }

        _uploadedGraphPath = null;
        _uploadedGraphFileName = null;
        _graphUploadMessage = "Upload cleared.";
        _graphUploadError = null;
        return Task.CompletedTask;
    }

    private async Task TriggerGraphSeedAsync()
    {
        _isImporting = true;
        _graphFeedback = null;
        try
        {
            var seedPath = _uploadedGraphPath;
            if (string.IsNullOrWhiteSpace(seedPath))
            {
                _graphFeedback = "Upload an RDF file before running import.";
                return;
            }

            if (_uploadedGraphPath is not null && !File.Exists(_uploadedGraphPath))
            {
                _graphFeedback = "Uploaded file was not found on disk. Please upload again.";
                return;
            }

            var request = new GraphSeedRequest(seedPath, _graphTenant, _graphTenantName);
            var result = await Metrics.TriggerGraphSeedAsync(request);
            _graphStatus = result;
            _graphFeedback = result.Success
                ? "Import completed."
                : $"Import failed: {result.Message ?? "Unknown error"}";
        }
        catch (Exception ex)
        {
            _graphFeedback = $"Import failed: {ex.Message}";
        }
        finally
        {
            _isImporting = false;
        }
    }

    private string GetGraphUploadDirectory()
    {
        var configured = Configuration["ADMIN_GRAPH_UPLOAD_DIR"]
            ?? Configuration["Admin:GraphUploadDirectory"];
        if (!string.IsNullOrWhiteSpace(configured))
        {
            return configured;
        }

        return Path.Combine(Path.GetTempPath(), "orleans-telemetry-uploads");
    }

    private long GetGraphUploadMaxBytes()
    {
        var configured = Configuration["ADMIN_GRAPH_UPLOAD_MAX_BYTES"]
            ?? Configuration["Admin:GraphUploadMaxBytes"];
        return long.TryParse(configured, out var maxBytes) ? maxBytes : DefaultGraphUploadLimitBytes;
    }

    private static void TryDeleteFile(string path)
    {
        try
        {
            if (File.Exists(path))
            {
                File.Delete(path);
            }
        }
        catch
        {
            // Best effort cleanup of temporary uploads.
        }
    }

    private async Task OnRealTimeToggleChanged()
    {
        if (_enableRealTimeUpdate)
        {
            await StartRealTimeUpdatesAsync();
        }
        else
        {
            await StopRealTimeUpdatesAsync();
        }
    }

    private async Task OnRealTimeCheckboxChanged(ChangeEventArgs args)
    {
        if (args.Value is bool isChecked)
        {
            _enableRealTimeUpdate = isChecked;
            StateHasChanged();
            
            if (isChecked)
            {
                await StartRealTimeUpdatesAsync();
            }
            else
            {
                await StopRealTimeUpdatesAsync();
            }
        }
    }

    private async Task StartRealTimeUpdatesAsync()
    {
        if (_selectedGraphNodeDetails is null)
        {
            _pointTrendError = "Select a point node before enabling real-time updates.";
            _enableRealTimeUpdate = false;
            StateHasChanged();
            return;
        }

        if (!TryResolvePointQueryContext(
            _selectedGraphNodeDetails,
            _selectedGraphTenant ?? string.Empty,
            out var tenantId,
            out var deviceId,
            out var pointId))
        {
            _pointTrendError = "Could not resolve Point context (tenant/device/point IDs missing).";
            _enableRealTimeUpdate = false;
            StateHasChanged();
            return;
        }

        try
        {
            await JS.InvokeVoidAsync("subscribeToPointUpdates", tenantId, deviceId, pointId, _dotNetRef);
            _isSubscribedToUpdates = true;
            _currentSubscriptionTenant = tenantId;
            _currentSubscriptionDevice = deviceId;
            _currentSubscriptionPoint = pointId;
            _pointTrendError = null;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            _pointTrendError = $"Failed to start real-time updates: {ex.Message}";
            _enableRealTimeUpdate = false;
            _isSubscribedToUpdates = false;
            StateHasChanged();
        }
    }

    private async Task StopRealTimeUpdatesAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("unsubscribeFromPointUpdates");
            _isSubscribedToUpdates = false;
            _currentSubscriptionTenant = null;
            _currentSubscriptionDevice = null;
            _currentSubscriptionPoint = null;
            StateHasChanged();
        }
        catch
        {
            // Ignore errors during unsubscribe
        }
    }

    [JSInvokable]
    public async Task OnPointUpdate(PointUpdateDto update)
    {
        var newSample = new PointTrendSample(update.Timestamp, ExtractNumericValue(update.Value), update.Value?.ToString() ?? "null");
        
        var samples = _pointTrendSamples.ToList();
        samples.Add(newSample);
        
        // Keep only last 500 samples
        if (samples.Count > 500)
        {
            samples = samples.TakeLast(500).ToList();
        }
        
        _pointTrendSamples = samples;
        await InvokeAsync(StateHasChanged);
    }

    private static double? ExtractNumericValue(object? value)
    {
        if (value is null) return null;
        if (value is bool b) return b ? 1.0 : 0.0;
        if (value is IConvertible convertible)
        {
            try { return Convert.ToDouble(convertible); }
            catch { return null; }
        }
        return null;
    }

    public async ValueTask DisposeAsync()
    {
        if (_enableRealTimeUpdate)
        {
            await StopRealTimeUpdatesAsync();
        }
        _dotNetRef?.Dispose();
    }

    public sealed class PointUpdateDto
    {
        public DateTimeOffset Timestamp { get; set; }
        public object? Value { get; set; }
        public string PointId { get; set; } = string.Empty;
        public string DeviceId { get; set; } = string.Empty;
        public string TenantId { get; set; } = string.Empty;
    }
}
