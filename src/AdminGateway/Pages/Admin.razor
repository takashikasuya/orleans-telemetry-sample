@page "/"
@inject AdminMetricsService Metrics
@using System.Collections.Generic

<section class="admin-header">
    <div>
        <p class="eyebrow">Orleans Telemetry - 管理コンソール</p>
        <h1>Cluster Overview</h1>
    </div>
    <button class="refresh-button" @onclick="RefreshAsync">データを更新</button>
</section>

@if (_loading)
{
    <p class="status">ダッシュボードを読み込み中...</p>
}
else if (_error is not null)
{
    <p class="status error">@_error</p>
}
else
{
    <section class="overview">
        <article>
            <h2>Ingest</h2>
            <p>バッチサイズ: @_ingest?.BatchSize</p>
            <p>チャネル容量: @_ingest?.ChannelCapacity</p>
            <div class="tag-row">
                <strong>Connectors</strong>
                @if (_ingest?.EnabledConnectors.Length > 0)
                {
                    @foreach (var connector in _ingest.EnabledConnectors)
                    {
                        <span class="tag">@connector</span>
                    }
                }
                else
                {
                    <span class="tag muted">未構成</span>
                }
            </div>
            <div class="tag-row">
                <strong>Event sinks</strong>
                @if (_ingest?.EnabledSinks.Length > 0)
                {
                    @foreach (var sink in _ingest.EnabledSinks)
                    {
                        <span class="tag">@sink</span>
                    }
                }
                else
                {
                    <span class="tag muted">未構成</span>
                }
            </div>
        </article>
        <article>
            <h2>Storage</h2>
            @if (_storage is not null)
            {
                <p>Stage: @_storage.Stage.FileCount files</p>
                <p>Parquet: @_storage.Parquet.FileCount files</p>
                <p>インデックス: @_storage.Index.FileCount files</p>
            }
            else
            {
                <p>Storage stats unavailable.</p>
            }
        </article>
        <article>
            <h2>Clients</h2>
            <p>Silodis: @_silos.Length</p>
            <p>合計クライアント: @(_silos.Sum(s => s.ClientCount))</p>
        </article>
    </section>

    <section>
        <h2>Activation Explorer (@_grains.Length types)</h2>
        @if (_grains.Length == 0)
        {
            <p class="status muted">グレインデータがまだありません。</p>
        }
        else
        {
            <div class="table-scroll">
                <table>
                    <thead>
                        <tr>
                            <th>Grain Type</th>
                            <th>Activations</th>
                            <th>Silod</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var grain in _grains)
                        {
                            <tr>
                                <td>@grain.GrainType</td>
                                <td class="numeric">@grain.ActivationCount</td>
                                <td>@string.Join(", ", grain.Silos)</td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>
        }
    </section>

    <section>
        <h2>Client Connections</h2>
        @if (_silos.Length == 0)
        {
            <p class="status muted">シロ統計が取得できません。</p>
        }
        else
        {
            <div class="table-scroll">
                <table>
                    <thead>
                        <tr>
                            <th>Silo</th>
                            <th>Status</th>
                            <th>Clients</th>
                            <th>Activations</th>
                            <th>CPU (%)</th>
                            <th>Memory (used / max)</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var silo in _silos)
                        {
                            <tr>
                                <td>@silo.SiloAddress</td>
                                <td>@silo.Status</td>
                                <td class="numeric">@silo.ClientCount</td>
                                <td class="numeric">@silo.ActivationCount</td>
                                <td>@FormatPercent(silo.CpuUsagePercentage)</td>
                                <td>@FormatMemoryUsage(silo.MemoryUsageBytes, silo.MaximumAvailableMemoryBytes)</td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>
        }
    </section>

    <section>
        <h2>Storage Buckets</h2>
        <div class="tier-grid">
            @if (_storage is not null)
            {
                @foreach (var tier in new[] { _storage.Stage, _storage.Parquet, _storage.Index })
                {
                    <article>
                        <h3>@tier.Tier</h3>
                        <p>@FormatBytes(tier.TotalBytes) · @tier.FileCount files</p>
                        <p class="muted">ルート: @tier.RootPath</p>
                        <ul>
                            @if (tier.Tenants.Count == 0)
                            {
                                <li class="muted">アクティブなテナントがありません。</li>
                            }
                            else
                            {
                                @foreach (var tenant in tier.Tenants)
                                {
                                    <li>@tenant.TenantId · @tenant.FileCount files · @FormatBytes(tenant.TotalBytes)</li>
                                }
                            }
                        </ul>
                    </article>
                }
            }
            else
            {
                <p class="status muted">Storage stats failed to load.</p>
            }
        </div>
    </section>
    <section>
        <h2>Graph Statistics</h2>
        <div class="graph-tenant-selector">
            @if (_graphTenants.Length > 0)
            {
                <label>
                    Tenant
                    <select class="graph-input" value="@_selectedGraphTenant" @onchange="OnGraphTenantSelectionChanged">
                        @foreach (var tenant in _graphTenants)
                        {
                            <option value="@tenant">@tenant</option>
                        }
                    </select>
                </label>
            }
            else
            {
                <p class="status muted">RDF をインポートするとテナント ID が登録され、ここに表示されます。</p>
            }
        </div>
        @if (_graphStats is not null && !string.IsNullOrWhiteSpace(_selectedGraphTenant))
        {
            <p class="muted">Tenant: @_selectedGraphTenant</p>
            <table class="graph-stats-table">
                <thead>
                    <tr>
                        <th>Type</th>
                        <th>Count</th>
                        <th>Samples (ID · Class)</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var type in GraphStatOrder)
                    {
                        var samples = _graphStats.NodeSamples.TryGetValue(type, out var list) ? list : Array.Empty<GraphNodeDetail>();
                        <tr>
                            <td>@type</td>
                            <td class="numeric">@GetGraphStatCount(_graphStats, type)</td>
                            <td>
                                @if (samples.Count == 0)
                                {
                                    <span class="muted">No registered nodes</span>
                                }
                                else
                                {
                                    <ul>
                                        @foreach (var sample in samples)
                                        {
                                            <li>
                                                <strong>@sample.DisplayName</strong><br />
                                                <small>@sample.NodeId · @sample.NodeType</small>
                                            </li>
                                        }
                                    </ul>
                                }
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
        }
        else
        {
            <p class="status muted">Graph statistics unavailable.</p>
        }
    </section>

    <section>
        <h2>Graph Hierarchy</h2>
        <button class="refresh-button" @onclick="LoadGraphHierarchyAsync" disabled="@string.IsNullOrWhiteSpace(_selectedGraphTenant)">階層を読み込む</button>
        @if (string.IsNullOrWhiteSpace(_selectedGraphTenant))
        {
            <p class="status muted">Tenant を選択してください。</p>
        }
        else if (_graphRenderNodes.Count > 0)
        {
            <div class="graph-network-wrapper">
                <div class="graph-network-canvas">
                    <svg width="@_graphCanvasWidth" height="@_graphCanvasHeight" role="img" aria-label="Graph network">
                        @foreach (var edge in _graphRenderEdges)
                        {
                            if (_renderNodeMap.TryGetValue(edge.SourceId, out var source) && _renderNodeMap.TryGetValue(edge.TargetId, out var target))
                            {
                                <line class="graph-edge" x1="@source.X" y1="@source.Y" x2="@target.X" y2="@target.Y" />
                                <svg:text class="graph-edge-label" x="@((source.X + target.X) / 2)" y="@((source.Y + target.Y) / 2 - 5)">
                                    @edge.Predicate
                                </svg:text>
                            }
                        }
                        @foreach (var node in _graphRenderNodes)
                        {
                            var isActive = string.Equals(_selectedGraphNode?.Node?.NodeId, node.NodeId, StringComparison.OrdinalIgnoreCase);
                            <g class="graph-node-group" @onclick="() => SelectGraphNode(node.NodeId)" tabindex="0">
                                <circle class="graph-node @(isActive ? "active" : "")" cx="@node.X" cy="@node.Y" r="18" />
                                <svg:text class="graph-node-label" x="@node.X" y="@(node.Y + 5)">
                                    @node.DisplayName
                                </svg:text>
                            </g>
                        }
                    </svg>
                </div>
                <aside class="graph-node-details">
                    @if (_selectedGraphNode is not null)
                    {
                        <h3>@GetNodeLabel(_selectedGraphNode)</h3>
                        <p><strong>ID:</strong> @_selectedGraphNode.Node?.NodeId</p>
                        <p><strong>Class:</strong> @_selectedGraphNode.Node?.NodeType</p>
                        <p><strong>Attributes:</strong></p>
                        <ul>
                            @foreach (var attr in _selectedGraphNode.Node?.Attributes ?? new Dictionary<string, string>())
                            {
                                <li>@attr.Key: @attr.Value</li>
                            }
                        </ul>
                    }
                    else
                    {
                        <p class="muted">ノードをクリックして詳細を表示します。</p>
                    }
                </aside>
            </div>
        }
        else if (_loadingHierarchy)
        {
            <p class="status">階層データを読み込み中...</p>
        }
        else
        {
            <p class="status muted">階層データがありません。</p>
        }
    </section>

    <section>
        <h2>Graph RDF Import</h2>
        <div class="graph-import-grid">
            <div class="graph-import">
                <label>
                    RDF path
                    <input class="graph-input" @bind="_graphPath" />
                </label>
                <label>
                    Tenant
                    <input class="graph-input" @bind="_graphTenant" />
                </label>
                <button class="refresh-button" @onclick="TriggerGraphSeedAsync" disabled="@_isImporting">
                    @_isImporting ? "実行中..." : "インポートを実行"
                </button>
            </div>
            <div class="graph-status-card">
                <div class="graph-status-header">
                    <span>Last execution</span>
                    <span class="@GetGraphStatusBadgeClass(_graphStatus)">@GetGraphStatusLabel(_graphStatus)</span>
                </div>
                @if (_graphStatus is not null)
                {
                    <p class="graph-status-line">パス: @_graphStatus.Path</p>
                    <p class="graph-status-line">テナント: @_graphStatus.TenantId</p>
                    <p class="graph-status-line">@_graphStatus.StartedAt:u → @_graphStatus.CompletedAt:u</p>
                    <p class="graph-status-line">ノード: @_graphStatus.NodeCount · エッジ: @_graphStatus.EdgeCount</p>
                    @if (!string.IsNullOrWhiteSpace(_graphStatus.Message))
                    {
                        <p class="graph-status-line status muted">メッセージ: @_graphStatus.Message</p>
                    }
                }
                else
                {
                    <p class="graph-status-line muted">Graph seed の実行履歴がありません。</p>
                }
            </div>
        </div>
        @if (!string.IsNullOrWhiteSpace(_graphFeedback))
        {
            <p class="status">@_graphFeedback</p>
        }
    </section>
}

@code {
    private static readonly GraphNodeType[] GraphStatOrder = new[]
    {
        GraphNodeType.Site,
        GraphNodeType.Building,
        GraphNodeType.Level,
        GraphNodeType.Area,
        GraphNodeType.Equipment,
        GraphNodeType.Point
    };

    private GrainActivationSummary[] _grains = Array.Empty<GrainActivationSummary>();
    private SiloSummary[] _silos = Array.Empty<SiloSummary>();
    private StorageOverview? _storage;
    private IngestSummary? _ingest;
    private bool _loading = true;
    private string? _error;
    private string _graphPath = "/seed/seed.ttl";
    private string _graphTenant = "default";
    private GraphSeedStatus? _graphStatus;
    private bool _isImporting;
    private string? _graphFeedback;
    private string[] _graphTenants = Array.Empty<string>();
    private string? _selectedGraphTenant;
    private GraphStatisticsSummary? _graphStats;
    private GraphNodeHierarchy? _graphHierarchy;
    private Dictionary<string, GraphNodeSnapshot> _graphNodeLookup = new(StringComparer.OrdinalIgnoreCase);
    private List<GraphRenderNode> _graphRenderNodes = new();
    private List<GraphRenderEdge> _graphRenderEdges = new();
    private Dictionary<string, GraphRenderNode> _renderNodeMap = new(StringComparer.OrdinalIgnoreCase);
    private double _graphCanvasWidth;
    private double _graphCanvasHeight;
    private GraphNodeSnapshot? _selectedGraphNode;
    private bool _loadingHierarchy;

    protected override async Task OnInitializedAsync()
    {
        await RefreshAsync();
    }

    private async Task RefreshAsync()
    {
        _loading = true;
        _error = null;
        try
        {
            _grains = await Metrics.GetGrainActivationsAsync();
            _silos = await Metrics.GetSiloSummariesAsync();
            _storage = await Metrics.GetStorageOverviewAsync(CancellationToken.None);
            _ingest = Metrics.GetIngestSummary();
            _graphStatus = await Metrics.GetLastGraphSeedStatusAsync();
            await LoadGraphTenantOptionsAsync();
            await LoadGraphStatisticsAsync();
        }
        catch (Exception ex)
        {
            _error = $"読み込みに失敗: {ex.Message}";
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    private async Task LoadGraphHierarchyAsync()
    {
        if (string.IsNullOrWhiteSpace(_selectedGraphTenant))
        {
            _graphHierarchy = null;
            _graphNodeLookup = new(StringComparer.OrdinalIgnoreCase);
            ResetGraphRenderState();
            return;
        }

        _loadingHierarchy = true;
        try
        {
            _graphHierarchy = await Metrics.GetGraphHierarchyAsync(_selectedGraphTenant);
            _graphNodeLookup = BuildNodeLookup(_graphHierarchy);
            BuildGraphRenderState();
        }
        catch (Exception ex)
        {
            _error = $"階層読み込みに失敗: {ex.Message}";
        }
        finally
        {
            _loadingHierarchy = false;
            StateHasChanged();
        }
    }

    private async Task LoadGraphTenantOptionsAsync()
    {
        var tenants = await Metrics.GetGraphTenantsAsync();
        _graphTenants = tenants ?? Array.Empty<string>();

        if (_graphTenants.Length == 0)
        {
            _selectedGraphTenant = null;
            return;
        }

        if (string.IsNullOrWhiteSpace(_selectedGraphTenant) ||
            !Array.Exists(_graphTenants, tenant => string.Equals(tenant, _selectedGraphTenant, System.StringComparison.OrdinalIgnoreCase)))
        {
            _selectedGraphTenant = _graphTenants[0];
        }

        if (string.Equals(_graphTenant, "default", System.StringComparison.OrdinalIgnoreCase) &&
            !string.IsNullOrWhiteSpace(_selectedGraphTenant))
        {
            _graphTenant = _selectedGraphTenant;
        }
    }

    private async Task LoadGraphStatisticsAsync()
    {
        if (string.IsNullOrWhiteSpace(_selectedGraphTenant))
        {
            _graphStats = null;
            return;
        }

        _graphStats = await Metrics.GetGraphStatisticsAsync(_selectedGraphTenant);
    }

    private async Task OnGraphTenantSelectionChanged(ChangeEventArgs args)
    {
        if (args?.Value is not string tenant || string.IsNullOrWhiteSpace(tenant))
        {
            return;
        }

        _selectedGraphTenant = tenant;
        await LoadGraphStatisticsAsync();
        _graphHierarchy = null;
        _graphNodeLookup = new(StringComparer.OrdinalIgnoreCase);
        ResetGraphRenderState();
        StateHasChanged();
    }

    private static Dictionary<string, GraphNodeSnapshot> BuildNodeLookup(GraphNodeHierarchy? hierarchy)
    {
        if (hierarchy is null)
        {
            return new(StringComparer.OrdinalIgnoreCase);
        }

        return hierarchy.Nodes
            .Where(snapshot => snapshot.Node?.NodeId is { } id && !string.IsNullOrWhiteSpace(id))
            .DistinctBy(snapshot => snapshot.Node!.NodeId, StringComparer.OrdinalIgnoreCase)
            .ToDictionary(snapshot => snapshot.Node!.NodeId, snapshot => snapshot, StringComparer.OrdinalIgnoreCase);
    }

    private static int GetGraphStatCount(GraphStatisticsSummary stats, GraphNodeType type)
        => type switch
        {
            GraphNodeType.Site => stats.SiteCount,
            GraphNodeType.Building => stats.BuildingCount,
            GraphNodeType.Level => stats.LevelCount,
            GraphNodeType.Area => stats.AreaCount,
            GraphNodeType.Equipment => stats.EquipmentCount,
            GraphNodeType.Point => stats.PointCount,
            _ => 0
        };

    private void ResetGraphRenderState()
    {
        _graphRenderNodes.Clear();
        _graphRenderEdges.Clear();
        _renderNodeMap.Clear();
        _graphCanvasWidth = 0;
        _graphCanvasHeight = 0;
        _selectedGraphNode = null;
    }

    private void BuildGraphRenderState()
    {
        ResetGraphRenderState();

        if (_graphHierarchy is null)
        {
            return;
        }

        var columnSpacing = 180;
        var rowSpacing = 70;
        var maxNodesPerColumn = 12;
        var maxY = 0.0;

        for (var columnIndex = 0; columnIndex < GraphStatOrder.Length; columnIndex++)
        {
            var nodeType = GraphStatOrder[columnIndex];
            var snapshots = _graphHierarchy.Nodes
                .Where(snapshot => snapshot.Node?.NodeType == nodeType && !string.IsNullOrWhiteSpace(snapshot.Node.NodeId))
                .DistinctBy(snapshot => snapshot.Node!.NodeId, StringComparer.OrdinalIgnoreCase)
                .Take(maxNodesPerColumn)
                .ToList();

            for (var rowIndex = 0; rowIndex < snapshots.Count; rowIndex++)
            {
                var snapshot = snapshots[rowIndex];
                var nodeId = snapshot.Node!.NodeId;
                var displayName = string.IsNullOrWhiteSpace(snapshot.Node.DisplayName) ? nodeId : snapshot.Node.DisplayName;
                var x = columnIndex * columnSpacing + 60;
                var y = 40 + rowIndex * rowSpacing;
                var renderNode = new GraphRenderNode(nodeId, snapshot.Node.NodeType, displayName, x, y);
                _graphRenderNodes.Add(renderNode);
                _renderNodeMap[nodeId] = renderNode;
                maxY = Math.Max(maxY, y);
            }
        }

        _graphCanvasWidth = GraphStatOrder.Length * columnSpacing + 80;
        _graphCanvasHeight = Math.Max(240, maxY + 80);

        var allowedPredicates = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "hasBuilding", "hasLevel", "hasPart", "hasArea",
            "hasEquipment", "hasPoint", "isLocationOf", "locatedIn"
        };

        foreach (var node in _graphRenderNodes)
        {
            if (!_graphNodeLookup.TryGetValue(node.NodeId, out var snapshot))
            {
                continue;
            }

            foreach (var edge in snapshot.OutgoingEdges)
            {
                if (string.IsNullOrWhiteSpace(edge.TargetNodeId) || !allowedPredicates.Contains(edge.Predicate))
                {
                    continue;
                }

                if (!_renderNodeMap.ContainsKey(edge.TargetNodeId))
                {
                    continue;
                }

                _graphRenderEdges.Add(new GraphRenderEdge(node.NodeId, edge.TargetNodeId, edge.Predicate));
            }
        }
    }

    private void SelectGraphNode(string nodeId)
    {
        if (string.IsNullOrWhiteSpace(nodeId))
        {
            _selectedGraphNode = null;
            return;
        }

        _selectedGraphNode = _graphNodeLookup.TryGetValue(nodeId, out var snapshot) ? snapshot : null;
    }

    private static string GetNodeLabel(GraphNodeSnapshot? snapshot)
    {
        if (snapshot?.Node is not { } node)
        {
            return "(unknown)";
        }

        return !string.IsNullOrWhiteSpace(node.DisplayName) ? node.DisplayName : node.NodeId;
    }

    private sealed record GraphRenderNode(string NodeId, GraphNodeType NodeType, string DisplayName, double X, double Y);
    private sealed record GraphRenderEdge(string SourceId, string TargetId, string Predicate);

    private static string FormatBytes(long? bytes) => FormatBytes((double?)bytes);

    private static string FormatBytes(double? bytes)
    {
        if (!bytes.HasValue)
        {
            return "-";
        }

        var value = bytes.Value;
        var units = new[] { "B", "KB", "MB", "GB", "TB" };
        var index = 0;
        while (value >= 1024 && index < units.Length - 1)
        {
            value /= 1024;
            index++;
        }

        return $"{value:F1} {units[index]}";
    }

    private static string FormatPercent(double? value)
        => value.HasValue ? $"{value.Value:F1}%" : "-";

    private static string FormatMemoryUsage(double? used, double? available)
    {
        if (!used.HasValue && !available.HasValue)
        {
            return "-";
        }

        var usedText = FormatBytes(used);
        if (!available.HasValue)
        {
            return usedText;
        }

        return $"{usedText} / {FormatBytes(available)}";
    }

    private static string GetGraphStatusLabel(GraphSeedStatus? status)
        => status is null ? "未実行" : status.Success ? "成功" : "失敗";

    private static string GetGraphStatusBadgeClass(GraphSeedStatus? status)
        => status is null ? "status-badge muted" : status.Success ? "status-badge success" : "status-badge failure";

    private async Task TriggerGraphSeedAsync()
    {
        _isImporting = true;
        _graphFeedback = null;
        try
        {
            var request = new GraphSeedRequest(_graphPath, _graphTenant);
            var result = await Metrics.TriggerGraphSeedAsync(request);
            _graphStatus = result;
            _graphFeedback = result.Success ? "インポートが完了しました。" : $"失敗: {result.Message ?? "未知のエラー"}";
        }
        catch (Exception ex)
        {
            _graphFeedback = $"インポートで例外: {ex.Message}";
        }
        finally
        {
            _isImporting = false;
        }
    }
}
